502 - 667

//	private void calcTimeSerMulti(List<RTable> rtable, PSOVector position, PSOVector worker, double workLoad) {
//		// TODO position is time_server, rtable is list of node including virtual node
//		// must be assigned
////		0 Man Man 0
////		1 W1 Man 1
////		2 W3 W1 2
////		3 W5 W1 2
////		4 W2 Man 1
////		5 W4 W2 2
////		6 W5 W2 2
//		// position.setById(0, worker.getById(0) * workLoad /
//		// rtable.get(0).getResource());
//		for (RTable r : rtable) {
//			double t_compute = 0;
//			double t_trans;
//
//			t_compute = worker.getById(r.getId()) * workLoad / r.getResource();
//			if (r.getNpath() > 1) {
//				// process with r.getDes()
//				for (RTable r2 : rtable) {
//					if ((r2.getDes().equals(r.getDes())) && (r2.getId() != r.getId())) {
//						t_compute += worker.getById(r2.getId()) * workLoad / r2.getResource();
//
//					}
//				}
//			}
//
//			t_trans = (worker.getById(r.getId()) * workLoad / Constants.BW) * r.getHop();
//
//			if (r.getId() == 0) {
//				t_trans = 0;
//			}
//			;
//			position.setById(r.getId(), t_trans + t_compute);
//
//		}
//
////		for (int i=1; i<=rtable.size();i++) {	
////			position.setById(i, worker.getById(i)*workLoad/Constants.BW + t_compute);
////		}
//
//	}

//	public PSOVector mainFunction(PSOParticle p, int workLoad, PSOVector currentWorkload, Node bestNode,
//			List<RTable> rtable) {
//		/**
//		 * @param workLoad        number of images from 1 service
//		 * @param p               percent workload
//		 * @param Theta           share service or not ( 0 or 1)
//		 * @param currentWorkload current workload at that node
//		 * @return total time
//		 */
//		PSOVector position = p.getPosition().clone();
//		// Vector p_temp = position.clone(); // for 2nd part
//
//		PSOVector Theta = new PSOVector(nodes);
//		for (int i = 0; i < position.getVectorCoordinate().length; i++) {
//			if (position.getById(i) != 0) {
//				Theta.setById(i, 1);
//			}
//		}
//
//		PSOVector worker = p.getPosition().getVectorRatio(); // get ratio
//		PSOVector worker_temp = worker.clone();
//		PSOVector workerCWL = currentWorkload.getVectorRatio(); // Worker current Workload
//
//		// double man = p.getPosition().getById(0);
//		// double manCWL = currentWorkload.getById(0); //Manager current Workload
//
//		/*
//		 * Calculate time for manager
//		 */
////        double Tman = (man*workLoad*0.005 + 0.619)   // y = 0.005*x + 0.0619   ~ P*Wi / Bij
////        				+ (0.0199*man*workLoad+0.291)    // y = 0.0199*x + 0.291 ~ P.Wi / fi
////        				+ (0.0199*manCWL+0.291)*Theta.getById(0) // (y = 0.0199*x + 0.291)*Theta ~ Theta*Ni/fi
////        				+ 0.047675; // Ri / Bij
//
//		/*
//		 * calculate time for workers
//		 */
//
//		// worker represent t_serve on Node.
//
//		// y = 0.004*x + 0.0619 ~ P*Wi / Bij
//		// worker.mul(workLoad * 0.004);
//
//		// double a = worker.getById(0);
//
//		double[] coef = new double[nodes]; // workers = nodes ... ignore Man
//		// Arrays.fill(coef, 0.619);
//		// worker.add(coef);
//
//		// y = 0.033*x + 0.469 ~ P.Wi / fi
//		worker_temp.mul(workLoad * 0.033);
//		// Arrays.fill(coef, 0.469);
//		worker_temp.add(coef);
//
//		// (y = 0.05*x + 1.244)*Theta ~ Theta*Ni/fi
//		// workerCWL.mul(0.033);
//		// workerCWL.add(coef);
//		// Vector Theta_worker = Theta.getWorkerVector();
//		// workerCWL.mulVector(Theta_worker);
//
//		// Ri / Bij
//		// Arrays.fill(coef, 0.047675 );
//		// worker.add(coef);
//
//		// Sum of 4 parts:
//
////    	worker.add(worker_temp.getVectorCoordinate());
////    	worker.add(workerCWL.getVectorCoordinate());
////    	
////    	for(int i = 0; i< position.getVectorCoordinate().length; i++){
////    		if(i==0){
////    			position.setById(i, Util.caclTimeCompute(bestNode));
////    			continue;   			
////    		}
////    		for(Node n:bestNode.getNodeChild()) {
////    			position.setById(i, Util.caclTimeCompute(n)+Util.caclTimeTrans(n,bestNode));
////    		}
////    		
////    		
////    		i++;
////
////    		
////    		
////    	//	System.out.println("DEBUG" + i + " " + position.getVectorCoordinate().length);
////    		position.setById(i, worker.getById(i));
////    	}
//
//		// System.out.println("BestNode in PSO is " + bestNode.getId());
//
//		// TODO
//		// calc time serve
//
////		for (Node n : bestNode.getNodeChild()) {
////			position.setById(n.getId(), Util.caclTimeCompute(n) + Util.caclTimeTrans(n, bestNode));
////			if (!n.getNodeChild().isEmpty()) {
////				for (Node nc : n.getNodeChild()) {
////					position.setById(nc.getId(), Util.caclTimeCompute(nc) + 2 * Util.caclTimeTrans(nc, bestNode));
////				}
////			}
////		}
//		// System.out.println("CALC TIME");
//		// calcTimeSer(bestNode, position);
//
//		// LOL
//		// If all nodes join in calc, we can for all node and calc to root.
//		// the function aims to scan all child and descendants.
//		//calcTimeSerMulti(rtable, position, worker, workLoad);
//		return position;
//
//	}

//	private void calcTimeSer(Node root, PSOVector position) {
//		System.out.println("DEBUG calcTimeSer");
//		if (!root.getNodeChild().isEmpty()) {
//			for (Node n : root.getNodeChild()) {
//				position.setById(n.getId(), Util.caclTimeCompute(n) + (n.getLvl()) * Util.caclTimeTrans(n, root));
//				// System.out.println("DEBUG calc node " + n.getId() + " -> " + " hc " +
//				// n.getLvl());
//				calcTimeSer(n, position);
//			}
//		}
//
//	}

765 - 938

//	static PSOVector constraintF3(int workLoad, PSOVector currentWorkload, PSOVector postion, double cWL,
//			HashMap<Integer, List<RTable>> mapRTable, PSOVector worker, List<RTable> rtable) {
//		// double averageWorkload = (workLoad + currentWorkload.getSum()) /
//		// postion.getVectorCoordinate().length;
//		// System.out.println("worker: " + worker.getById(1));
//		int numM = 1;
//		double B = Constants.B;
//		for (Integer id : mapRTable.keySet()) {
//			List<RTable> rtableMap = mapRTable.get(id);
//			List<String> check = new ArrayList<String>();
//			for (RTable r : rtableMap) {
//				String nodeID = r.getDes();
//				if (!check.contains(nodeID)) {
//					numM++;
//					check.add(nodeID);
//				}
//			}
//		}
//
//		numM /= mapRTable.size();
//		double NM = Constants.NUM_REQ / numM;
//
//		HashMap<String, Integer> paths = Util.getPahts(rtable);
//
//		int j = 0;
//		for (RTable r : rtable) {
//			double path = paths.get(r.getDes());
//			double pen1 = worker.getById(j) - NM / path;
//			// double pen2= worker.getById(j) - (NM / path)/10;
//			String debug = r.getDes();
//
//			if (pen1 > 0) {
//				postion.setById(j, postion.getById(j) + pen1 * B);
//
//				// if (debug.equals("14")) {
////					 System.out.println(" Route " + r.getRoute() + " p "
////					 +worker.getById(j));
////				}
//			}
//
////			if (pen2 < 0) {
////			postion.setById(j, postion.getById(j) + pen2);
////			}
//
//			j++;
//		}
//
////		for (Integer id : mapRTable.keySet()) {
////			List<RTable> rtable = mapRTable.get(id);
////			double WL = rtable.get(0).getReq().getWL();
////			HashMap<String, Double> wlNode = new HashMap<String, Double>();
////
////			for (RTable r : rtable) {
////				String nodeID = r.getDes();
////				double wlN=worker.getById(r.getId())*WL;
////				int path =1;
////				for (RTable r2 : rtable) {
////					if((r2.getDes()==r.getDes())&&(r.getId()!=r2.getId())) {
////						double test1 = worker.getById(r.getId());
////						wlN+=worker.getById(r2.getId())*WL;
////						//if (r2.getNpath()>path) path = r2.getNpath();
////						path++;
////					}
////				}
////				wlNode.put(nodeID, wlN*path);
////			}
////
////						
////			// calc p
////			for (RTable r : rtable) {
////				double pen1 = worker.getById(r.getId()) - workLoad/wlNode.get(r.getDes());
////				double pen2 = worker.getById(r.getId()) - wlNode.get(r.getDes())/2;
////
////				//System.out.println("pen: " + worker.getById(r.getId()));
////				if (pen1 > 0) {
////				postion.setById(j, postion.getById(j) + pen1);
////				}
////				
//////				if (pen2 < 0) {
//////					postion.setById(j, postion.getById(j) + pen2);
//////					}
////				
////				j++;
////			}
////			
////
////			
////		}
//
////		double averageWorkload = (workLoad + cWL) / postion.getVectorCoordinate().length;
////		boolean check = true;
////		for (int i = 0; i < postion.getVectorCoordinate().length; i++) {
////			double pen = postion.getById(i) - averageWorkload / workLoad;
////			if (pen > 0) {
////				postion.setById(i, postion.getById(i) + pen);
////				check = false;
////			}
////		}
//		return postion;
//	}

	/**
	 * pW >= aW aW=10
	 * 
	 * @param p
	 * @param workLoad
	 * @param rtable
	 * @param worker
	 * @param mapRTable
	 * @return
//	 */
//	static PSOVector constraintF4(int workLoad, PSOVector postion, double cWL, List<RTable> rtable, PSOVector worker,
//			HashMap<Integer, List<RTable>> mapRTable) {
////		boolean check = true;
////		int numM = 1;
////		double B=Constants.B;
////		for (Integer id : mapRTable.keySet()) {
////			List<RTable> rtableMap = mapRTable.get(id);
////			List<String> check = new ArrayList<String>();
////			for (RTable r : rtableMap) {
////				String nodeID = r.getDes();
////				if (!check.contains(nodeID)) {
////					numM++;
////					check.add(nodeID);
////				}
////			}
////		}
////
////		numM /= mapRTable.size();
//		HashMap<String, Integer> paths = Util.getPahts(rtable);
////
////		double NM = Constants.NUM_REQ / numM;
//
//		double a = Constants.RES[Constants.TYPE.VEHICLE.ordinal()] / Constants.BW;
//		HashMap<String, Double> sump = new HashMap<String, Double>();
//		double C = Constants.C;
//		int j = 0;
//
//		for (RTable r : rtable) {
//			String nodeID = r.getDes();
//			double p = worker.getById(j);
//
//			int j2 = 0;
//			for (RTable r2 : rtable) {
//				if ((r2.getDes().equals(r.getDes()))
//						&& (r2.getId() != r.getId() || (r2.getReq().getId() != r.getReq().getId()))) {
//					p += worker.getById(j2);
//
//				}
//				j2++;
//			}
//
//			double path = paths.get(r.getDes());
//			// a=(NM / path)/5;
//			double pen = p - a;
//
//			if (pen < 0) {
//				postion.setById(j, postion.getById(j) - pen * C);
//			}
//
//			sump.put(nodeID, p);
//			j++;
//		}
////		double averageWorkload = (workLoad + cWL) / postion.getVectorCoordinate().length;
////		// double a = averageWorkload / 10;
////		
////		for (int i = 0; i < postion.getVectorCoordinate().length; i++) {
////			double pen = (postion.getById(i) - a) / workLoad;
////			if (pen < 0)
////				postion.setById(i, postion.getById(i) - pen);
////			check = false;
////		}
//		return postion;
//	}